import os.pathfrom enum import Enumimport threadingimport argparseimport socketfrom pathlib import Pathclass client:    # ******************** TYPES *********************    # *    # * @brief Return codes for the protocol methods    class RC(Enum):        OK = 0        ERROR = 1        USER_ERROR = 2        THIRD_ERROR = 3        FOURTH_ERROR = 4    # ****************** ATTRIBUTES ******************    _server = None    _port = -1    _user = None    _myport = -1    _myip = socket.gethostbyname(socket.gethostname())    _islistening = False    _hilo = None    # ******************** AUXILIARY VALIDATION FUNCTIONS *********************    @staticmethod    def validate_size(data):        """        Validates that argument fits in 256 bytes.        """        if isinstance(data, str):            data_bytes = data.encode('utf-8')        else:            data_bytes = data        if len(data_bytes) > 256:            return False        return True    @staticmethod    def validate_no_blanks(fileName):        """        Validates that file name does not contain whitespace characters.        """        if any(c.isspace() for c in fileName):            return False        return True    @staticmethod    def asign_port():        """        Searches for a valid port number for the client to listen to other clients (work as a server).        """        return 12345    @staticmethod    def read_socket(sock):        """Esta función lee el dato enviado por el socket hasta detectar el fin de cadena y devuelve el mensaje completo"""        fin = False        message = b""        while not fin:            # iterar hasta leer toda la cadena            recv_message = sock.recv(1)            if recv_message:                message += recv_message                if b'\0' in recv_message:                    fin = True        return message    # ******************** PEER METHODS *******************    @staticmethod    def tratar_peticion(sd_req, req_client_data):        #1. Lectura de parámetros        try:            message = client.read_socket(sd_req).decode('utf-8')  #lectura código de operación            if message == "GET_FILE":                path_name = client.read_socket(req_client_data).decode('utf-8') #lectura del path        except socket.error as error:            print(f"Error de lectura por socket: {error}")            sd_req.close()            return        # 2. Comprobar si existe el fichero        path = Path(path_name)        if path.is_file():            with open(path, "rb") as file:                content = file.read()                size = len(content)                result = 0        else:            result = 1        # 3. Envío de respuesta y fichero        try:            sd_req.sendall(str(result).encode() + b'\0')        #escritura de resultado            if result == 0:                sd_req.sendall(str(size).encode() + b'\0')      #escritura de tamaño de fichero                sd_req.sendall(str(content).encode() + b'\0')   #escritura de contenido        except socket.error as error:            print(f"Error de escritura por socket: {error}")            sd_req.close()            return        sd_req.close()        return    @staticmethod    def listen():        # Inicializar el nuevo socket        req_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)        req_socket.bind((client._myip, client._myport))        req_socket.listen()        #Bucle de escucha de peticiones        while client._islistening:            try:                sd_req, req_client_data = req_socket.accept()                client.tratar_peticion(sd_req, req_client_data)    # ******************** CLIENT METHODS *******************    @staticmethod    def register(user):        # Comprobación de corrección del argumento        if not client.validate_size(user) or not client.validate_no_blanks(user):            return client.RC.USER_ERROR        # 1. Conexión al servidor        try:            sd_client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)            sd_client.connect((client._server, client._port))        except socket.error as error:            print(f"Error de conexión por socket: {error}")  # TODO: quitar antes de entregar            return client.RC.USER_ERROR        # 2. Envío de petición        try:            message = b'REGISTER\0'            sd_client.sendall(message)  # escritura código de operación            sd_client.sendall(user.encode() + b'\0')  # escritura username        except socket.error as error:            print(f"Error de escritura por socket: {error}")            return client.RC.USER_ERROR        # 3. Recepción de respuesta        try:            message = client.read_socket(sd_client)            # Transformar a número el mensaje recibido del servidor para entenderlo            result = int(message.rstrip(b'\0'))        except socket.error as error:            print(f"Error de lectura por socket: {error}")            return client.RC.USER_ERROR        finally:            # 4. Cierre de conexión.            sd_client.close()        return client.RC(result)    @staticmethod    def unregister(user):        # Comprobación de corrección del argumento        if not client.validate_size(user) or not client.validate_no_blanks(user):            return client.RC.USER_ERROR        # 1. Conexión al servidor        try:            sd_client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)            sd_client.connect((client._server, client._port))        except socket.error as error:            print(f"Error de conexión por socket: {error}")            return client.RC.USER_ERROR        # 2. Envío de petición        try:            message = b'UNREGISTER\0'            sd_client.sendall(message)  # escritura código de operación            sd_client.sendall(user.encode() + b'\0')  # escritura username        except socket.error as error:            print(f"Error de escritura por socket: {error}")            return client.RC.USER_ERROR        # 3. Recepción de respuesta        try:            message = client.read_socket(sd_client)            # Transformar a número el mensaje recibido del servidor para entenderlo            result = int(message.rstrip(b'\0'))        except socket.error as error:            print(f"Error de lectura por socket: {error}")            return client.RC.USER_ERROR        finally:            # 4. Cierre de conexión.            sd_client.close()        return client.RC(result)    @staticmethod    def connect(user):        # Comprobación de corrección del argumento        if not client.validate_size(user) or not client.validate_no_blanks(user):            return client.RC.USER_ERROR        # 1. Conexión al servidor        try:            sd_client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)            sd_client.connect((client._server, client._port))        except socket.error as error:            print(f"Error de conexión por socket: {error}")            return client.RC.USER_ERROR        # 2. Asignación de puerto de escucha del cliente        client._myport = client.asign_port()        # 3. Lanzar hilo de escucha        client._islistening = True        client._hilo = threading.Thread(target=client.listen, daemon=True)        client._hilo.start()        # 3. Envío de petición        try:            message = b'CONNECT\0'            sd_client.sendall(message)  # escritura código de operación            sd_client.sendall(user.encode() + b'\0')  # escritura username            sd_client.sendall(str(client._myport).encode() + b'\0')  # escritura puerto de escucha        except socket.error as error:            print(f"Error de escritura por socket: {error}")            client._islistening = False            client._hilo.join()            return client.RC.USER_ERROR        # 4. Recepción de respuesta        result = -1        try:            message = client.read_socket(sd_client)            # Transformar a número el mensaje recibido del servidor para entenderlo            result = int(message.rstrip(b'\0'))        except socket.error as error:            print(f"Error de lectura por socket: {error}")            client._islistening = False            client._hilo.join()            return client.RC.USER_ERROR        finally:            # 5. Cierre de conexión.            sd_client.close()            # 6. Guardar nombre de usuario            client._user = user        return client.RC(result)    @staticmethod    def disconnect(user):        # Comprobación de corrección del argumento        if not client.validate_size(user) or not client.validate_no_blanks(user):            return client.RC.USER_ERROR        # 1. Conexión al servidor        try:            sd_client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)            sd_client.connect((client._server, client._port))        except socket.error as error:            print(f"Error de conexión por socket: {error}")            return client.RC.USER_ERROR        # 2. Envío de petición        try:            message = b'DISCONNECT\0'            sd_client.sendall(message)  # escritura código de operación            sd_client.sendall(user.encode() + b'\0')  # escritura username        except socket.error as error:            print(f"Error de escritura por socket: {error}")            return client.RC.USER_ERROR        # 3. Recepción de respuesta        try:            message = client.read_socket(sd_client)            # Transformar a número el mensaje recibido del servidor para entenderlo            result = int(message.rstrip(b'\0'))        except socket.error as error:            print(f"Error de lectura por socket: {error}")            return client.RC.USER_ERROR        # 4. Cierre de conexión.        finally:            sd_client.close()            # 5. Eliminar puerto de escucha y terminar hilo de peticiones            client._myport = None            client._islistening = False            client._hilo.join()        return client.RC(result)    @staticmethod    def publish(fileName, description):        # Comprobación de corrección del argumento        if (not client.validate_size(fileName) or not client.validate_size(description) or                not client.validate_no_blanks(fileName)):            return client.RC.USER_ERROR        # 1. Conexión al servidor        try:            sd_client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)            sd_client.connect((client._server, client._port))        except socket.error as error:            print(f"Error de conexión por socket: {error}")            return client.RC.USER_ERROR        # 2. Envío de petición        try:            message = b'PUBLISH\0'            sd_client.sendall(message)  # escritura código de operación            sd_client.sendall(client._user.encode() + b'\0')  # escritura username que manda la solicitud            sd_client.sendall(fileName.encode() + b'\0')  # escritura file name            sd_client.sendall(description.encode() + b'\0')  # escritura description        except socket.error as error:            print(f"Error de escritura por socket: {error}")            return client.RC.USER_ERROR        # 3. Recepción de respuesta        try:            message = client.read_socket(sd_client)            # Transformar a número el mensaje recibido del servidor para entenderlo            result = int(message.rstrip(b'\0'))        except socket.error as error:            print(f"Error de lectura por socket: {error}")            return client.RC.USER_ERROR        finally:            # 4. Cierre de conexión.            sd_client.close()        return client.RC(result)    @staticmethod    def delete(fileName):        # Comprobación de corrección del argumento        if not client.validate_size(fileName) or not client.validate_no_blanks(fileName):            return client.RC.USER_ERROR        # 1. Conexión al servidor        try:            sd_client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)            sd_client.connect((client._server, client._port))        except socket.error as error:            print(f"Error de conexión por socket: {error}")            return client.RC.USER_ERROR        # 2. Envío de petición        try:            message = b'DELETE\0'            sd_client.sendall(message)  # escritura código de operación            sd_client.sendall(client._user.encode() + b'\0')  # escritura username del cliente            sd_client.sendall(fileName.encode() + b'\0')  # escritura file name        except socket.error as error:            print(f"Error de escritura por socket: {error}")            return client.RC.USER_ERROR        # 3. Recepción de respuesta        try:            message = client.read_socket(sd_client)            # Transformar a número el mensaje recibido del servidor para entenderlo            result = int(message.rstrip(b'\0'))        except socket.error as error:            print(f"Error de lectura por socket: {error}")            return client.RC.USER_ERROR        finally:            # 4. Cierre de conexión.            sd_client.close()        return client.RC(result)    @staticmethod    def listusers():        # 1. Conexión al servidor        try:            sd_client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)            sd_client.connect((client._server, client._port))        except socket.error as error:            print(f"Error de conexión por socket: {error}")            return client.RC.USER_ERROR        # 2. Envío de petición        try:            message = b'LIST_USERS\0'            sd_client.sendall(message)  # escritura código de operación            sd_client.sendall(client._user.encode() + b'\0')  # escritura username del cliente        except socket.error as error:            print(f"Error de escritura por socket: {error}")            return client.RC.USER_ERROR        # 3. Recepción de respuesta        try:            message = client.read_socket(sd_client)  # TODO: update llamadas de lectura en el cliente            # Transformar a número el mensaje recibido del servidor para entenderlo            result = int(message.rstrip(b'\0'))            if result == 0:                print("LIST USERS OK")                # lectura del número de datos a recibir                message = client.read_socket(sd_client)                num_files = int(message.rstrip(b'\0'))                # Bucle: lectura de datos de usuarios                for i in range(num_files):                    message_user = client.read_socket(sd_client).decode('utf-8')  # lectura username                    message_ip = client.read_socket(sd_client).decode('utf-8')  # lectura ip                    message_port = client.read_socket(sd_client).decode('utf-8')  # lectura puerto                    # Impresión de los datos del usuario                    print(message_user, " ", message_ip, " ", message_port)        except socket.error as error:            print(f"Error de lectura por socket: {error}")            return client.RC.USER_ERROR        finally:            # 4. Cierre de conexión.            sd_client.close()        return client.RC(result)    @staticmethod    def listcontent(user):        # Comprobación de corrección del argumento        if not client.validate_size(user):            return client.RC.USER_ERROR        # 1. Conexión al servidor        try:            sd_client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)            sd_client.connect((client._server, client._port))        except socket.error as error:            print(f"Error de conexión por socket: {error}")            return client.RC.USER_ERROR        # 2. Envío de petición        try:            message = b'LIST_CONTENT\0'            sd_client.sendall(message)  # escritura código de operación            sd_client.sendall(client._user.encode() + b'\0')  # escritura username del cliente            sd_client.sendall(user.encode() + b'\0')  # escritura user a buscar        except socket.error as error:            print(f"Error de escritura por socket: {error}")            return client.RC.USER_ERROR        # 3. Recepción de respuesta        try:            message = client.read_socket(sd_client)            # Transformar a número el mensaje recibido del servidor para entenderlo            result = int(message.rstrip(b'\0'))            if result == 0:                print("LIST CONTENT OK")                # lectura del número de datos a recibir                message = client.read_socket(sd_client)                num_files = int(message.rstrip(b'\0'))                # Bucle: lectura de datos de usuarios                for i in range(num_files):                    message_file = client.read_socket(sd_client).decode('utf-8')  # lectura filename                    # Impresión de los datos del fichero                    print(message_file)        except socket.error as error:            print(f"Error de lectura por socket: {error}")            return client.RC.USER_ERROR        finally:            # 4. Cierre de conexión.            sd_client.close()        return client.RC(result)    @staticmethod    def getfile(user, remote_FileName, local_FileName):        # Comprobación de corrección del argumento        if not client.validate_size(user) or not client.validate_size(remote_FileName) or not client.validate_size(                local_FileName) or not client.validate_no_blanks(remote_FileName) or not client.validate_no_blanks(                local_FileName):            return client.RC.USER_ERROR        #  Write your code here        return client.RC.ERROR    # *    # **    # * @brief Command interpreter for the client. It calls the protocol functions.    @staticmethod    def shell():        while (True):            try:                command = input("c> ")                line = command.split(" ")                if (len(line) > 0):                    line[0] = line[0].upper()                    if (line[0] == "REGISTER"):                        if (len(line) == 2):                            result = client.register(line[1])                            if result == 0:                                print("c> REGISTER OK")                            elif result == 1:                                print("c> USERNAME IN USE")                            else:                                print("c> REGISTER FAIL")                        else:                            print("Syntax error. Usage: REGISTER <userName>")                    elif (line[0] == "UNREGISTER"):                        if (len(line) == 2):                            result = client.unregister(line[1])                            if result == 0:                                print("c> UNREGISTER OK")                            elif result == 1:                                print("c> USER DOES NOT EXIST")                            else:                                print("c> UNREGISTER FAIL")                        else:                            print("Syntax error. Usage: UNREGISTER <userName>")                    elif (line[0] == "CONNECT"):                        if (len(line) == 2):                            result = client.connect(line[1])                            if result == 0:                                print("c> CONNECT OK")                            elif result == 1:                                print("c>  CONNECT FAIL , USER DOES NOT EXIST")                            elif result == 2:                                print("c> USER ALREADY CONNECTED")                            else:                                print("CONNECT FAIL")                        else:                            print("Syntax error. Usage: CONNECT <userName>")                    elif (line[0] == "PUBLISH"):                        if (len(line) >= 3):                            #  Remove first two words                            description = ' '.join(line[2:])                            result = client.publish(line[1], description)                            if result == 0:                                print("c> PUBLISH OK")                            elif result == 1:                                print("c>  PUBLISH FAIL , USER DOES NOT EXIST")                            elif result == 2:                                print("c> PUBLISH FAIL, USER NOT CONNECTED")                            elif result == 3:                                print("PUBLISH FAIL , CONTENT ALREADY PUBLISHED")                            else:                                print("CONNECT FAIL")                        else:                            print("Syntax error. Usage: PUBLISH <fileName> <description>")                    elif (line[0] == "DELETE"):                        if (len(line) == 2):                            result = client.delete(line[1])                            if result == 0:                                print("c> DELTE OK")                            elif result == 1:                                print("c>  DELETE FAIL , USER DOES NOT EXIST")                            elif result == 2:                                print("c> DELETE FAIL, USER NOT CONNECTED")                            elif result == 3:                                print("DELETE FAIL , CONTENT NOT PUBLISHED")                            else:                                print("DELETE FAIL")                        else:                            print("Syntax error. Usage: DELETE <fileName>")                    elif (line[0] == "LIST_USERS"):                        if (len(line) == 1):                            result = client.listusers()                            if result == 1:                                print("c>  LIST_USERS FAIL , USER DOES NOT EXIST")                            elif result == 2:                                print("c> LIST_USERS FAIL, USER NOT CONNECTED")                            else:                                print("LIST_USERS FAIL")                        else:                            print("Syntax error. Use: LIST_USERS")                    elif (line[0] == "LIST_CONTENT"):                        if (len(line) == 2):                            result = client.listcontent(line[1])                            if result == 1:                                print("c>  LIST_CONTENT FAIL , USER DOES NOT EXIST")                            elif result == 2:                                print("c> LIST_CONTENT FAIL, USER NOT CONNECTED")                            elif result == 3:                                print("c>  LIST_CONTENT FAIL , REMOTE USER DOES NOT EXIST")                            else:                                print("LIST_CONTENT FAIL")                        else:                            print("Syntax error. Usage: LIST_CONTENT <userName>")                    elif (line[0] == "DISCONNECT"):                        if (len(line) == 2):                            result = client.disconnect(line[1])                            if result == 0:                                print("c> DISCONNECT OK")                            elif result == 1:                                print("c>  DISCONNECT FAIL , USER DOES NOT EXIST")                            elif result == 2:                                print("c> DISCONNECT FAIL, USER NOT CONNECTED")                            else:                                print("DISCONNECT FAIL")                        else:                            print("Syntax error. Usage: DISCONNECT <userName>")                    elif (line[0] == "GET_FILE"):                        if (len(line) == 4):                            result = client.getfile(line[1], line[2], line[3])                            if result == 0:                                print("c> GET_FILE OK")                            elif result == 1:                                print("c>  GET_FILE FAIL , FILE NOT EXIST")                            else:                                print("GET_FILE FAIL")                        else:                            print("Syntax error. Usage: GET_FILE <userName> <remote_fileName> <local_fileName>")                    elif (line[0] == "QUIT"):                        if (len(line) == 1):                            client.disconnect(client._user)                            break                        else:                            print("Syntax error. Use: QUIT")                    else:                        print("Error: command " + line[0] + " not valid.")            except Exception as e:                print("Exception: " + str(e))    # *    # * @brief Prints program usage    @staticmethod    def usage():        print("Usage: python3 client.py -s <server> -p <port>")    # *    # * @brief Parses program execution arguments    @staticmethod    def parseArguments(argv):        parser = argparse.ArgumentParser()        parser.add_argument('-s', type=str, required=True, help='Server IP')        parser.add_argument('-p', type=int, required=True, help='Server Port')        args = parser.parse_args()        if (args.s is None):            parser.error("Usage: python3 client.py -s <server> -p <port>")            return False        if ((args.p < 1024) or (args.p > 65535)):            parser.error("Error: Port must be in the range 1024 <= port <= 65535");            return False;        client._server = args.s        client._port = args.p        return True    # ******************** MAIN *********************    @staticmethod    def main(argv):        if (not client.parseArguments(argv)):            client.usage()            return        #  Write code here        client.shell()        print("+++ FINISHED +++")if __name__ == "__main__":    client.main([])