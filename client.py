from enum import Enumimport argparseimport socketclass client :    # ******************** TYPES *********************    # *    # * @brief Return codes for the protocol methods    class RC(Enum) :        OK = 0        ERROR = 1        USER_ERROR = 2        THIRD_ERROR = 3        FOURTH_ERROR = 4    # ****************** ATTRIBUTES ******************    _server = None    _port = -1    _user = None    _myport = -1    # ******************** AUXILIARY VALIDATION FUNCTIONS *********************    @staticmethod    def validate_size(data):        """        Validates that argument fits in 256 bytes.        """        if isinstance(data, str):            data_bytes = data.encode('utf-8')        else:            data_bytes = data        if len(data_bytes) > 256:            return False        return True    @staticmethod    def validate_no_blanks(fileName):        """        Validates that file name does not contain whitespace characters.        """        if any(c.isspace() for c in fileName):            return False        return True    @staticmethod    def asign_port():        """        Searches for a valid port number for the client to listen to other clients (work as a server).        """        return 12345    # ******************** METHODS *******************    @staticmethod    def  register(user) :        # Comprobación de corrección del argumento        if not client.validate_size(user) or not client.validate_no_blanks(user):            return client.RC.USER_ERROR        #1. Conexión al servidor        try:            sd_client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)            sd_client.connect((client._server,client._port))        except socket.error as error :            print(f"Error de conexión por socket: {error}")            return client.RC.USER_ERROR        #2. Envío de petición        try:            message= b'REGISTER\0'            sd_client.sendall(message)  # escritura código de operación            sd_client.sendall(user.encode() + b'\0')     # escritura username        except socket.error as error :            print(f"Error de escritura por socket: {error}")            return client.RC.USER_ERROR        # 3. Recepción de respuesta        try:            fin = False            message= b""            while not fin:                #iterar hasta leer toda la cadena                recv_message = sd_client.recv(1)                if recv_message:                    message += recv_message                    if b'\0' in recv_message:                        fin = True            result = int(message.rstrip(b'\0'))        except socket.error as error:            print(f"Error de lectura por socket: {error}")            return client.RC.USER_ERROR        finally:            # 4. Cierre de conexión.            sd_client.close()        return client.RC(result)    @staticmethod    def  unregister(user) :        # Comprobación de corrección del argumento        if not client.validate_size(user) or not client.validate_no_blanks(user):            return client.RC.USER_ERROR        #1. Conexión al servidor        try:            sd_client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)            sd_client.connect((client._server,client._port))        except socket.error as error :            print(f"Error de conexión por socket: {error}")            return client.RC.USER_ERROR        #2. Envío de petición        try:            message= b'UNREGISTER\0'            sd_client.sendall(message)  # escritura código de operación            sd_client.sendall(user.encode() + b'\0')     # escritura username        except socket.error as error :            print(f"Error de escritura por socket: {error}")            return client.RC.USER_ERROR        # 3. Recepción de respuesta        try:            fin = False            message= b""            while not fin:                #iterar hasta leer toda la cadena                recv_message = sd_client.recv(1)                if recv_message:                    message += recv_message                    if b'\0' in recv_message:                        fin = True            # Transformar a número el mensaje recibido del servidor para entenderlo            result = int(message.rstrip(b'\0'))        except socket.error as error:            print(f"Error de lectura por socket: {error}")            return client.RC.USER_ERROR        finally:            # 4. Cierre de conexión.            sd_client.close()        return client.RC(result)    @staticmethod    def  connect(user) :        # Comprobación de corrección del argumento        if not client.validate_size(user) or not client.validate_no_blanks(user):            return client.RC.USER_ERROR        # 1. Conexión al servidor        try:            sd_client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)            sd_client.connect((client._server, client._port))        except socket.error as error:            print(f"Error de conexión por socket: {error}")            return client.RC.USER_ERROR        # 2. Asignación de puerto de escucha del cliente        client._myport = client.asign_port()        # 3. Envío de petición        try:            message = b'CONNECT\0'            sd_client.sendall(message)                  # escritura código de operación            sd_client.sendall(user.encode() + b'\0')    # escritura username            sd_client.sendall(str(client._myport).encode() + b'\0')    # escritura puerto de escucha        except socket.error as error:            print(f"Error de escritura por socket: {error}")            return client.RC.USER_ERROR        # 4. Recepción de respuesta        try:            fin = False            message = b""            while not fin:                # iterar hasta leer toda la cadena                recv_message = sd_client.recv(1)                if recv_message:                    message += recv_message                    if b'\0' in recv_message:                        fin = True            # Transformar a número el mensaje recibido del servidor para entenderlo            result = int(message.rstrip(b'\0'))        except socket.error as error:            print(f"Error de lectura por socket: {error}")            return client.RC.USER_ERROR        finally:            # 5. Cierre de conexión.            sd_client.close()            # 6. Guardar nombre de usuario            client._user = user        return client.RC(result)    @staticmethod    def  disconnect(user) :        # Comprobación de corrección del argumento        if not client.validate_size(user) or not client.validate_no_blanks(user):            return client.RC.USER_ERROR        # 1. Conexión al servidor        try:            sd_client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)            sd_client.connect((client._server, client._port))        except socket.error as error:            print(f"Error de conexión por socket: {error}")            return client.RC.USER_ERROR        # 2. Envío de petición        try:            message = b'DISCONNECT\0'            sd_client.sendall(message)  # escritura código de operación            sd_client.sendall(user.encode() + b'\0')  # escritura username        except socket.error as error:            print(f"Error de escritura por socket: {error}")            return client.RC.USER_ERROR        # 3. Recepción de respuesta        try:            fin = False            message = b""            while not fin:                # iterar hasta leer toda la cadena                recv_message = sd_client.recv(1)                if recv_message:                    message += recv_message                    if b'\0' in recv_message:                        fin = True            # Transformar a número el mensaje recibido del servidor para entenderlo            result = int(message.rstrip(b'\0'))        except socket.error as error:            print(f"Error de lectura por socket: {error}")            return client.RC.USER_ERROR        # 4. Cierre de conexión.        finally:            sd_client.close()            # 5. Eliminar puerto de escucha y borrar usuario            client._myport = None            client._user = None        return client.RC(result)    @staticmethod    def  publish(fileName,  description) :        # Comprobación de corrección del argumento        if (not client.validate_size(fileName) or not client.validate_size(description) or            not client.validate_no_blanks(fileName)):            return client.RC.USER_ERROR        # 1. Conexión al servidor        try:            sd_client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)            sd_client.connect((client._server, client._port))        except socket.error as error:            print(f"Error de conexión por socket: {error}")            return client.RC.USER_ERROR        # 2. Envío de petición        try:            message = b'PUBLISH\0'            sd_client.sendall(message)                       # escritura código de operación            sd_client.sendall(client._user.encode() + b'\0') # escritura username que manda la solicitud            sd_client.sendall(fileName.encode() + b'\0')     # escritura file name            sd_client.sendall(description.encode() + b'\0')  # escritura description        except socket.error as error:            print(f"Error de escritura por socket: {error}")            return client.RC.USER_ERROR        # 3. Recepción de respuesta        try:            fin = False            message = b""            while not fin:                # iterar hasta leer toda la cadena                recv_message = sd_client.recv(1)                if recv_message:                    message += recv_message                    if b'\0' in recv_message:                        fin = True            # Transformar a número el mensaje recibido del servidor para entenderlo            result = int(message.rstrip(b'\0'))        except socket.error as error:            print(f"Error de lectura por socket: {error}")            return client.RC.USER_ERROR        finally:            # 4. Cierre de conexión.            sd_client.close()        return client.RC(result)    @staticmethod    def  delete(fileName) :        # Comprobación de corrección del argumento        if not client.validate_size(fileName) or not client.validate_no_blanks(fileName):            return client.RC.USER_ERROR        # 1. Conexión al servidor        try:            sd_client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)            sd_client.connect((client._server, client._port))        except socket.error as error:            print(f"Error de conexión por socket: {error}")            return client.RC.USER_ERROR        # 2. Envío de petición        try:            message = b'DELETE\0'            sd_client.sendall(message)                       # escritura código de operación            sd_client.sendall(client._user.encode() + b'\0')         # escritura username del cliente            sd_client.sendall(fileName.encode() + b'\0')     # escritura file name        except socket.error as error:            print(f"Error de escritura por socket: {error}")            return client.RC.USER_ERROR        # 3. Recepción de respuesta        try:            fin = False            message = b""            while not fin:                # iterar hasta leer toda la cadena                recv_message = sd_client.recv(1)                if recv_message:                    message += recv_message                    if b'\0' in recv_message:                        fin = True            # Transformar a número el mensaje recibido del servidor para entenderlo            result = int(message.rstrip(b'\0'))        except socket.error as error:            print(f"Error de lectura por socket: {error}")            return client.RC.USER_ERROR        finally:            # 4. Cierre de conexión.            sd_client.close()        return client.RC(result)    @staticmethod    def  listusers() :        # 1. Conexión al servidor        try:            sd_client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)            sd_client.connect((client._server, client._port))        except socket.error as error:            print(f"Error de conexión por socket: {error}")            return client.RC.USER_ERROR        # 2. Envío de petición        try:            message = b'LIST_USERS\0'            sd_client.sendall(message)                       # escritura código de operación            sd_client.sendall(client._user.encode() + b'\0') # escritura username del cliente        except socket.error as error:            print(f"Error de escritura por socket: {error}")            return client.RC.USER_ERROR        # 3. Recepción de respuesta        try:            fin = False            message = b""            while not fin:                # iterar hasta leer toda la cadena                recv_message = sd_client.recv(1)                if recv_message:                    message += recv_message                    if b'\0' in recv_message:                        fin = True            # Transformar a número el mensaje recibido del servidor para entenderlo            result = int(message.rstrip(b'\0'))        except socket.error as error:            print(f"Error de lectura por socket: {error}")            return client.RC.USER_ERROR        finally:            # 4. Cierre de conexión.            sd_client.close()        return client.RC(result)    @staticmethod    def  listcontent(user) :        # Comprobación de corrección del argumento        if not client.validate_size(user) :            return client.RC.USER_ERROR        # 1. Conexión al servidor        try:            sd_client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)            sd_client.connect((client._server, client._port))        except socket.error as error:            print(f"Error de conexión por socket: {error}")            return client.RC.USER_ERROR        # 2. Envío de petición        try:            message = b'LIST_CONTENT\0'            sd_client.sendall(message)                       # escritura código de operación            sd_client.sendall(client._user.encode() + b'\0') # escritura username del cliente            sd_client.sendall(user.encode() + b'\0')         # escritura user a buscar        except socket.error as error:            print(f"Error de escritura por socket: {error}")            return client.RC.USER_ERROR        # 3. Recepción de respuesta        try:            fin = False            message = b""            while not fin:                # iterar hasta leer toda la cadena                recv_message = sd_client.recv(1)                if recv_message:                    message += recv_message                    if b'\0' in recv_message:                        fin = True            # Transformar a número el mensaje recibido del servidor para entenderlo            result = int(message.rstrip(b'\0'))        except socket.error as error:            print(f"Error de lectura por socket: {error}")            return client.RC.USER_ERROR        finally:            # 4. Cierre de conexión.            sd_client.close()        return client.RC(result)    @staticmethod    def  getfile(user,  remote_FileName,  local_FileName) :        # Comprobación de corrección del argumento        if not client.validate_size(user) or not client.validate_size(remote_FileName) or not client.validate_size(local_FileName) or not client.validate_no_blanks(remote_FileName) or not client.validate_no_blanks(local_FileName) :            return client.RC.USER_ERROR        #  Write your code here        return client.RC.ERROR    # *    # **    # * @brief Command interpreter for the client. It calls the protocol functions.    @staticmethod    def shell():        while (True) :            try :                command = input("c> ")                line = command.split(" ")                if (len(line) > 0):                    line[0] = line[0].upper()                    if (line[0]=="REGISTER") :                        if (len(line) == 2) :                            client.register(line[1])                        else :                            print("Syntax error. Usage: REGISTER <userName>")                    elif(line[0]=="UNREGISTER") :                        if (len(line) == 2) :                            client.unregister(line[1])                        else :                            print("Syntax error. Usage: UNREGISTER <userName>")                    elif(line[0]=="CONNECT") :                        if (len(line) == 2) :                            client.connect(line[1])                        else :                            print("Syntax error. Usage: CONNECT <userName>")                                        elif(line[0]=="PUBLISH") :                        if (len(line) >= 3) :                            #  Remove first two words                            description = ' '.join(line[2:])                            client.publish(line[1], description)                        else :                            print("Syntax error. Usage: PUBLISH <fileName> <description>")                    elif(line[0]=="DELETE") :                        if (len(line) == 2) :                            client.delete(line[1])                        else :                            print("Syntax error. Usage: DELETE <fileName>")                    elif(line[0]=="LIST_USERS") :                        if (len(line) == 1) :                            client.listusers()                        else :                            print("Syntax error. Use: LIST_USERS")                    elif(line[0]=="LIST_CONTENT") :                        if (len(line) == 2) :                            client.listcontent(line[1])                        else :                            print("Syntax error. Usage: LIST_CONTENT <userName>")                    elif(line[0]=="DISCONNECT") :                        if (len(line) == 2) :                            client.disconnect(line[1])                        else :                            print("Syntax error. Usage: DISCONNECT <userName>")                    elif(line[0]=="GET_FILE") :                        if (len(line) == 4) :                            client.getfile(line[1], line[2], line[3])                        else :                            print("Syntax error. Usage: GET_FILE <userName> <remote_fileName> <local_fileName>")                    elif(line[0]=="QUIT") :                        if (len(line) == 1) :                            break                        else :                            print("Syntax error. Use: QUIT")                    else :                        print("Error: command " + line[0] + " not valid.")            except Exception as e:                print("Exception: " + str(e))    # *    # * @brief Prints program usage    @staticmethod    def usage() :        print("Usage: python3 client.py -s <server> -p <port>")    # *    # * @brief Parses program execution arguments    @staticmethod    def  parseArguments(argv) :        parser = argparse.ArgumentParser()        parser.add_argument('-s', type=str, required=True, help='Server IP')        parser.add_argument('-p', type=int, required=True, help='Server Port')        args = parser.parse_args()        if (args.s is None):            parser.error("Usage: python3 client.py -s <server> -p <port>")            return False        if ((args.p < 1024) or (args.p > 65535)):            parser.error("Error: Port must be in the range 1024 <= port <= 65535");            return False;                client._server = args.s        client._port = args.p        return True    # ******************** MAIN *********************    @staticmethod    def main(argv) :        if (not client.parseArguments(argv)) :            client.usage()            return        #  Write code here        client.shell()        print("+++ FINISHED +++")    if __name__=="__main__":    client.main([])