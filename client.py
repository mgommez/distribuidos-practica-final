import os.pathfrom enum import Enumimport threadingimport argparseimport socketfrom pathlib import Pathclass client:    # ******************** TYPES *********************    # *    # * @brief Return codes for the protocol methods    class RC(Enum):        OK = 0        ERROR = 1        SECOND_ERROR = 2        THIRD_ERROR = 3        FOURTH_ERROR = 4    # ****************** ATTRIBUTES ******************    _server = None    _port = -1    _user = None    _myport = -1    _port_ready = None    _myip = socket.gethostbyname(socket.gethostname())    _islistening = False    _req_socket = None    _hilo = None    _otherUsers = []    _otherFiles = {"user": None,                   "files": []}    # ******************** AUXILIARY VALIDATION FUNCTIONS *********************    @staticmethod    def validate_size(data):        """        Validates that argument fits in 256 bytes.        """        if isinstance(data, str):            data_bytes = data.encode('utf-8')        else:            data_bytes = data        if len(data_bytes) > 256:            return False        return True    @staticmethod    def validate_no_blanks(fileName):        """        Validates that file name does not contain whitespace characters.        """        if any(c.isspace() for c in fileName):            return False        return True    @staticmethod    def asign_port():        """        Searches for a valid port number for the client to listen to other clients (work as a server).        """        return 12345    @staticmethod    def read_socket(sock):        """Esta función lee el dato enviado por el socket hasta detectar el fin de cadena y devuelve el mensaje completo"""        fin = False        message = b""        while not fin:            # iterar hasta leer toda la cadena            recv_message = sock.recv(1)            if recv_message:                message += recv_message                if b'\0' in recv_message:                    fin = True        return message    # ******************** PEER METHODS *******************    @staticmethod    def tratar_peticion(sd_req):        #1. Lectura de parámetros        try:            message = client.read_socket(sd_req).rstrip(b'\0').decode('utf-8')  #lectura código de operación            if message == "GET_FILE":                path_name = client.read_socket(sd_req).rstrip(b'\0').decode('utf-8') #lectura del path        except socket.error as error:            print(f"Error de lectura por socket: {error}")            sd_req.close()            return        # 2. Comprobar si existe el fichero        try:            with open(path_name, "rb") as file:                print("dentro de with open...")                content = file.read()                result = 0        except Exception as e:            print("Error al abrir archivo:", e)            result = 1        # 3. Envío de respuesta y fichero        try:            sd_req.sendall(str(result).encode() + b'\0')        #escritura de resultado            if result == 0:                sd_req.sendall(str(len(content)).encode() + b'\0')              #escritura de tamaño de fichero                sd_req.sendall(content + b'\0')                   #escritura de contenido        except socket.error as error:            print(f"Error de escritura por socket: {error}")            sd_req.close()            return        sd_req.close()        return    @staticmethod    def listen():        # Inicializar el nuevo socket        client._req_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)        # Asignar al cliente un puerto libre        client._req_socket.bind(('0.0.0.0', 0))        client._myport = client._req_socket.getsockname()[1]        client._req_socket = client._req_socket        # envía la señal de que el puerto está correctamente actualizado        client._port_ready.set()        client._req_socket.listen()        print("Estoy escuchando en el puerto", client._myport)        client._req_socket.settimeout(5)        # Bucle de escucha de peticiones        while client._islistening:            try:                sd_req, req_client_data = client._req_socket.accept()                client.tratar_peticion(sd_req)            except socket.timeout:                continue            except OSError:                break        try:            client._req_socket.close()        except Exception:            pass    # ******************** CLIENT METHODS *******************    @staticmethod    def register(user):        # Comprobación de corrección del argumento        if not client.validate_size(user) or not client.validate_no_blanks(user):            return client.RC.SECOND_ERROR        # 1. Conexión al servidor        try:            sd_client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)            sd_client.connect((client._server, client._port))        except socket.error as error:            print(f"Error de conexión por socket: {error}")  # TODO: quitar antes de entregar            return client.RC.SECOND_ERROR        # 2. Envío de petición        try:            message = b'REGISTER\0'            sd_client.sendall(message)  # escritura código de operación            sd_client.sendall(user.encode() + b'\0')  # escritura username        except socket.error as error:            print(f"Error de escritura por socket: {error}")            return client.RC.SECOND_ERROR        # 3. Recepción de respuesta        try:            message = client.read_socket(sd_client)            # Transformar a número el mensaje recibido            result = int(message.rstrip(b'\0'))        except socket.error as error:            print(f"Error de lectura por socket: {error}")            return client.RC.SECOND_ERROR        finally:            # 4. Cierre de conexión.            sd_client.close()        return client.RC(result)    @staticmethod    def unregister(user):        # Comprobación de corrección del argumento        if not client.validate_size(user) or not client.validate_no_blanks(user):            return client.RC.SECOND_ERROR        # 1. Conexión al servidor        try:            sd_client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)            sd_client.connect((client._server, client._port))        except socket.error as error:            print(f"Error de conexión por socket: {error}")            return client.RC.SECOND_ERROR        # 2. Envío de petición        try:            message = b'UNREGISTER\0'            sd_client.sendall(message)  # escritura código de operación            sd_client.sendall(user.encode() + b'\0')  # escritura username        except socket.error as error:            print(f"Error de escritura por socket: {error}")            return client.RC.SECOND_ERROR        # 3. Recepción de respuesta        try:            message = client.read_socket(sd_client)            # Transformar a número el mensaje recibido            result = int(message.rstrip(b'\0'))        except socket.error as error:            print(f"Error de lectura por socket: {error}")            return client.RC.SECOND_ERROR        finally:            # 4. Cierre de conexión.            sd_client.close()        return client.RC(result)    @staticmethod    def connect(user):        # Comprobación de corrección del argumento        if not client.validate_size(user) or not client.validate_no_blanks(user):            return client.RC.SECOND_ERROR        if client._myport != -1:            print("Ya hay una conexión en curso en el puerto", client._myport)            return client.RC.SECOND_ERROR        # 1. Conexión al servidor        try:            sd_client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)            sd_client.connect((client._server, client._port))        except socket.error as error:            print(f"Error de conexión por socket: {error}")            return client.RC.SECOND_ERROR        # para evitar condiciones de carrera sobre _myport        client._port_ready = threading.Event()        # 2. Lanzar hilo de escucha        client._islistening = True        client._hilo = threading.Thread(target=client.listen, daemon=True)        client._hilo.start()        # 3. Envío de petición        try:            message = b'CONNECT\0'            sd_client.sendall(message)                              # escritura código de operación            sd_client.sendall(user.encode() + b'\0')                # escritura username            # Espera a que el hilo de client.listen() asigne el puerto            client._port_ready.wait()            sd_client.sendall(str(client._myport).encode() + b'\0') # escritura puerto de escucha        except socket.error as error:            print(f"Error de escritura por socket: {error}")            # Eliminar puerto de escucha y terminar hilo de peticiones            client._myport = -1            client._islistening = False            client._req_socket.close()  # Forzar que el accept() falle si está esperando            client._hilo.join()            return client.RC.SECOND_ERROR        # 4. Recepción de respuesta        result = -1        try:            message = client.read_socket(sd_client)            # Transformar a número el mensaje recibido            result = int(message.rstrip(b'\0'))        except socket.error as error:            print(f"Error de lectura por socket: {error}")            client._islistening = False            client._hilo.join()            return client.RC.SECOND_ERROR        finally:            # 5. Cierre de conexión.            sd_client.close()            # 6. Guardar nombre de usuario            client._user = user        return client.RC(result)    @staticmethod    def disconnect(user):        # Comprobación de corrección del argumento        if not client.validate_size(user) or not client.validate_no_blanks(user):            return client.RC.SECOND_ERROR        # 1. Conexión al servidor        try:            sd_client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)            sd_client.connect((client._server, client._port))        except socket.error as error:            print(f"Error de conexión por socket: {error}")            return client.RC.SECOND_ERROR        # 2. Envío de petición        try:            message = b'DISCONNECT\0'            sd_client.sendall(message)  # escritura código de operación            sd_client.sendall(user.encode() + b'\0')  # escritura username        except socket.error as error:            print(f"Error de escritura por socket: {error}")            return client.RC.SECOND_ERROR        # 3. Recepción de respuesta        try:            message = client.read_socket(sd_client)            # Transformar a número el mensaje recibido            result = int(message.rstrip(b'\0'))        except socket.error as error:            print(f"Error de lectura por socket: {error}")            return client.RC.SECOND_ERROR        # 4. Cierre de conexión.        finally:            sd_client.close()            # 5. Eliminar puerto de escucha y terminar hilo de peticiones            client._myport = -1            client._islistening = False            client._req_socket.close()  # Forzar que el accept() falle si está esperando            client._hilo.join()        return client.RC(result)    @staticmethod    def publish(fileName, description):        # Comprobación de corrección del argumento        if (not client.validate_size(fileName) or not client.validate_size(description) or                not client.validate_no_blanks(fileName)):            return client.RC.SECOND_ERROR        # 1. Conexión al servidor        try:            sd_client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)            sd_client.connect((client._server, client._port))        except socket.error as error:            print(f"Error de conexión por socket: {error}")            return client.RC.SECOND_ERROR        # 2. Envío de petición        try:            message = b'PUBLISH\0'            sd_client.sendall(message)  # escritura código de operación            sd_client.sendall(client._user.encode() + b'\0')  # escritura username que manda la solicitud            sd_client.sendall(fileName.encode() + b'\0')  # escritura file name            sd_client.sendall(description.encode() + b'\0')  # escritura description        except socket.error as error:            print(f"Error de escritura por socket: {error}")            return client.RC.SECOND_ERROR        # 3. Recepción de respuesta        try:            message = client.read_socket(sd_client)            # Transformar a número el mensaje recibido            result = int(message.rstrip(b'\0'))        except socket.error as error:            print(f"Error de lectura por socket: {error}")            return client.RC.SECOND_ERROR        finally:            # 4. Cierre de conexión.            sd_client.close()        return client.RC(result)    @staticmethod    def delete(fileName):        # Comprobación de corrección del argumento        if not client.validate_size(fileName) or not client.validate_no_blanks(fileName):            return client.RC.SECOND_ERROR        # 1. Conexión al servidor        try:            sd_client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)            sd_client.connect((client._server, client._port))        except socket.error as error:            print(f"Error de conexión por socket: {error}")            return client.RC.SECOND_ERROR        # 2. Envío de petición        try:            message = b'DELETE\0'            sd_client.sendall(message)  # escritura código de operación            sd_client.sendall(client._user.encode() + b'\0')  # escritura username del cliente            sd_client.sendall(fileName.encode() + b'\0')  # escritura file name        except socket.error as error:            print(f"Error de escritura por socket: {error}")            return client.RC.SECOND_ERROR        # 3. Recepción de respuesta        try:            message = client.read_socket(sd_client)            # Transformar a número el mensaje recibido            result = int(message.rstrip(b'\0'))        except socket.error as error:            print(f"Error de lectura por socket: {error}")            return client.RC.SECOND_ERROR        finally:            # 4. Cierre de conexión.            sd_client.close()        return client.RC(result)    @staticmethod    def listusers():        # 1. Conexión al servidor        try:            sd_client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)            sd_client.connect((client._server, client._port))        except socket.error as error:            print(f"Error de conexión por socket: {error}")            return client.RC.SECOND_ERROR        # 2. Envío de petición        try:            message = b'LIST_USERS\0'            sd_client.sendall(message)  # escritura código de operación            sd_client.sendall(client._user.encode() + b'\0')  # escritura username del cliente        except socket.error as error:            print(f"Error de escritura por socket: {error}")            return client.RC.SECOND_ERROR        # 3. Recepción de respuesta        try:            message = client.read_socket(sd_client)  # TODO: update llamadas de lectura en el cliente            # Transformar a número el mensaje recibido            result = int(message.rstrip(b'\0'))            if result == 0:                # lectura del número de datos a recibir                message = client.read_socket(sd_client)                num_files = int(message.rstrip(b'\0'))                # Bucle: lectura de datos de usuarios                client._otherUsers = []                for i in range(num_files):                    message_user = client.read_socket(sd_client).rstrip(b'\0').decode('utf-8')  # lectura username                    message_ip = client.read_socket(sd_client).rstrip(b'\0').decode('utf-8')  # lectura ip                    message_port = client.read_socket(sd_client).rstrip(b'\0').decode('utf-8')  # lectura puerto                    # Guardado de los datos en la estructura de datos                    client._otherUsers.append(                        {"username": message_user,                         "ip": message_ip,                         "port": message_port                         }                    )        except socket.error as error:            print(f"Error de lectura por socket: {error}")            return client.RC.SECOND_ERROR        finally:            # 4. Cierre de conexión.            sd_client.close()        return client.RC(result)    @staticmethod    def listcontent(user):        # Comprobación de corrección del argumento        if not client.validate_size(user):            return client.RC.SECOND_ERROR        # 1. Conexión al servidor        try:            sd_client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)            sd_client.connect((client._server, client._port))        except socket.error as error:            print(f"Error de conexión por socket: {error}")            return client.RC.SECOND_ERROR        # 2. Envío de petición        try:            message = b'LIST_CONTENT\0'            sd_client.sendall(message)  # escritura código de operación            sd_client.sendall(client._user.encode() + b'\0')  # escritura username del cliente            sd_client.sendall(user.encode() + b'\0')  # escritura user a buscar        except socket.error as error:            print(f"Error de escritura por socket: {error}")            return client.RC.SECOND_ERROR        # 3. Recepción de respuesta        try:            message = client.read_socket(sd_client)            # Transformar a número el mensaje recibido            result = int(message.rstrip(b'\0'))            if result == 0:                # lectura del número de datos a recibir                message = client.read_socket(sd_client)                num_files = int(message.rstrip(b'\0'))                # Bucle: lectura de datos de usuarios                client._otherFiles["user"] = user                client._otherFiles["files"] = []                for i in range(num_files):                    message_file = client.read_socket(sd_client).rstrip(b'\0').decode('utf-8')  # lectura filename                    # Guardado de los datos en la estructura auxiliar                    client._otherFiles["files"].append(message_file)        except socket.error as error:            print(f"Error de lectura por socket: {error}")            return client.RC.SECOND_ERROR        finally:            # 4. Cierre de conexión.            sd_client.close()        return client.RC(result)    @staticmethod    def getfile(user, remote_FileName, local_FileName):        # Comprobaciones iniciales: conexión y argumentos        if client._port == -1:            # caso de error: el cliente no está conectado            return client.RC.ERROR        if (not client.validate_size(user)  or not client.validate_size(remote_FileName)                                            or not client.validate_size(local_FileName)                                            or not client.validate_no_blanks(remote_FileName)                                            or not client.validate_no_blanks(local_FileName)):            return client.RC.SECOND_ERROR        print("en getfile tras validaciones")        # 1. Conexión al cliente        # Obtener la ip y puerto del cliente.        client.listusers()        # buscar al cliente y leer sus datos        conectado = False        i = 0        other_ip, other_port = None, None        print(client._otherUsers)        while not conectado or i == len(client._otherUsers):            user_item = client._otherUsers[i]            print("en getfile buscando el user: ", user_item)            if user == user_item["username"]:                #si el usuario está conectado...                other_ip = user_item["ip"]                other_port = int(user_item["port"])                conectado = True            else:                i += 1            print("he salido del if bien")        if not conectado:            return client.RC.ERROR        print("en getfile tras búsqueda de cliente")        # conexión con el cliente        try:            sd_client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)            print            sd_client.connect((other_ip, other_port))        except socket.error as error:            print(f"Error de conexión por socket: {error}")            return client.RC.SECOND_ERROR        print("en getfile: me he conectado al cliente")        # 2. Envío de petición        try:            message = b'GET_FILE\0'            sd_client.sendall(message)  # escritura código de operación            sd_client.sendall(remote_FileName.encode() + b'\0')  # escritura filename pedido        except socket.error as error:            print(f"Error de escritura por socket: {error}")            return client.RC.SECOND_ERROR        print("en getfile tras petición")        # 3. Recepción de respuesta        try:            message = client.read_socket(sd_client)            # Transformar a número el mensaje recibido            result = int(message.rstrip(b'\0'))            if result == 0:                # se va a transmitir el archivo                message = client.read_socket(sd_client)     #lectura del tamaño                file_size = int(message.rstrip(b'\0'))                readbytes = 0                content = ""                message = b""                while readbytes < file_size:                    # leemos hasta conseguir la longitud del fichero                    message = client.read_socket(sd_client) # lectura del contenido                    print("aquí llego!!")                    readbytes += len(message.rstrip(b'\0'))                    content += message.rstrip(b'\0').decode('utf-8')                # 4. Escritura en fichero local                print("local filename: ", local_FileName)                with open(Path(local_FileName), "w") as file:                    file.write(content)        except socket.error as error:            print(f"Error de lectura por socket: {error}")            return client.RC.SECOND_ERROR        finally:            # 5. Cierre de conexión.            sd_client.close()        return client.RC(result)        return client.RC.ERROR    # *    # **    # * @brief Command interpreter for the client. It calls the protocol functions.    @staticmethod    def shell():        while (True):            try:                command = input("c> ")                line = command.split(" ")                if (len(line) > 0):                    line[0] = line[0].upper()                    if (line[0] == "REGISTER"):                        if (len(line) == 2):                            result = client.register(line[1])                            if result == client.RC.OK:                                print("c> REGISTER OK")                            elif result == client.RC.ERROR:                                print("c> USERNAME IN USE")                            else:                                print("c> REGISTER FAIL")                        else:                            print("Syntax error. Usage: REGISTER <userName>")                    elif (line[0] == "UNREGISTER"):                        if (len(line) == 2):                            result = client.unregister(line[1])                            if result == client.RC.OK:                                print("c> UNREGISTER OK")                            elif result == client.RC.ERROR:                                print("c> USER DOES NOT EXIST")                            else:                                print("c> UNREGISTER FAIL")                        else:                            print("Syntax error. Usage: UNREGISTER <userName>")                    elif (line[0] == "CONNECT"):                        if (len(line) == 2):                            result = client.connect(line[1])                            if result == client.RC.OK:                                print("c> CONNECT OK")                            elif result == client.RC.ERROR:                                print("c>  CONNECT FAIL , USER DOES NOT EXIST")                            elif result == client.RC.SECOND_ERROR:                                print("c> USER ALREADY CONNECTED")                            else:                                print("c> CONNECT FAIL")                        else:                            print("Syntax error. Usage: CONNECT <userName>")                    elif (line[0] == "PUBLISH"):                        if (len(line) >= 3):                            #  Remove first two words                            description = ' '.join(line[2:])                            result = client.publish(line[1], description)                            if result == client.RC.OK:                                print("c> PUBLISH OK")                            elif result == client.RC.ERROR:                                print("c>  PUBLISH FAIL , USER DOES NOT EXIST")                            elif result == client.RC.SECOND_ERROR:                                print("c> PUBLISH FAIL, USER NOT CONNECTED")                            elif result == client.RC.THIRD_ERROR:                                print("c> PUBLISH FAIL , CONTENT ALREADY PUBLISHED")                            else:                                print("c> PUBLISH FAIL")                        else:                            print("Syntax error. Usage: PUBLISH <fileName> <description>")                    elif (line[0] == "DELETE"):                        if (len(line) == 2):                            result = client.delete(line[1])                            if result == client.RC.OK:                                print("c> DELTE OK")                            elif result == client.RC.ERROR:                                print("c>  DELETE FAIL , USER DOES NOT EXIST")                            elif result == client.RC.SECOND_ERROR:                                print("c> DELETE FAIL, USER NOT CONNECTED")                            elif result == client.RC.THIRD_ERROR:                                print("c> DELETE FAIL , CONTENT NOT PUBLISHED")                            else:                                print("c> DELETE FAIL")                        else:                            print("Syntax error. Usage: DELETE <fileName>")                    elif (line[0] == "LIST_USERS"):                        if (len(line) == 1):                            result = client.listusers()                            if result== client.RC.OK:                                print("c> LIST_USERS OK")                                #impresión de usuarios guardados en la variable auxiliar                                for user in client._otherUsers:                                    print("\t \t", user["username"], " ", user["ip"], " ", user["port"])                            elif result == client.RC.ERROR:                                print("c>  LIST_USERS FAIL , USER DOES NOT EXIST")                            elif result == client.RC.SECOND_ERROR:                                print("c> LIST_USERS FAIL, USER NOT CONNECTED")                            else:                                print("c> LIST_USERS FAIL")                        else:                            print("Syntax error. Use: LIST_USERS")                    elif (line[0] == "LIST_CONTENT"):                        if (len(line) == 2):                            result = client.listcontent(line[1])                            if result == client.RC.OK:                                print("c> LIST_CONTENT OK")                                #impresión de filenames guardados en la variable auxiliar                                for file in client._otherFiles["files"]:                                    print("\t \t", file)                            elif result == client.RC.ERROR:                                print("c>  LIST_CONTENT FAIL , USER DOES NOT EXIST")                            elif result == client.RC.SECOND_ERROR:                                print("c> LIST_CONTENT FAIL, USER NOT CONNECTED")                            elif result == client.RC.THIRD_ERROR:                                print("c>  LIST_CONTENT FAIL , REMOTE USER DOES NOT EXIST")                            else:                                print("c> LIST_CONTENT FAIL")                        else:                            print("Syntax error. Usage: LIST_CONTENT <userName>")                    elif (line[0] == "DISCONNECT"):                        if (len(line) == 2):                            result = client.disconnect(line[1])                            if result == client.RC.OK:                                print("c> DISCONNECT OK")                            elif result == client.RC.ERROR:                                print("c>  DISCONNECT FAIL , USER DOES NOT EXIST")                            elif result == client.RC.SECOND_ERROR:                                print("c> DISCONNECT FAIL, USER NOT CONNECTED")                            else:                                print("c> DISCONNECT FAIL")                        else:                            print("Syntax error. Usage: DISCONNECT <userName>")                    elif (line[0] == "GET_FILE"):                        if (len(line) == 4):                            result = client.getfile(line[1], line[2], line[3])                            if result == client.RC.OK:                                print("c> GET_FILE OK")                            elif result == client.RC.ERROR:                                print("c>  GET_FILE FAIL , FILE NOT EXIST")                            else:                                print("c> GET_FILE FAIL")                        else:                            print("Syntax error. Usage: GET_FILE <userName> <remote_fileName> <local_fileName>")                    elif (line[0] == "QUIT"):                        if (len(line) == 1):                            if client._myport != -1:                                #Desconectar el cliente antes de cerrar                                client.disconnect(client._user)                            break                        else:                            print("Syntax error. Use: QUIT")                    else:                        print("Error: command " + line[0] + " not valid.")            except Exception as e:                print("Exception: " + str(e))    # *    # * @brief Prints program usage    @staticmethod    def usage():        print("Usage: python3 client.py -s <server> -p <port>")    # *    # * @brief Parses program execution arguments    @staticmethod    def parseArguments(argv):        parser = argparse.ArgumentParser()        parser.add_argument('-s', type=str, required=True, help='Server IP')        parser.add_argument('-p', type=int, required=True, help='Server Port')        args = parser.parse_args()        if (args.s is None):            parser.error("Usage: python3 client.py -s <server> -p <port>")            return False        if ((args.p < 1024) or (args.p > 65535)):            parser.error("Error: Port must be in the range 1024 <= port <= 65535");            return False;        client._server = args.s        client._port = args.p        return True    # ******************** MAIN *********************    @staticmethod    def main(argv):        if (not client.parseArguments(argv)):            client.usage()            return        #  Write code here        client.shell()        print("+++ FINISHED +++")if __name__ == "__main__":    client.main([])